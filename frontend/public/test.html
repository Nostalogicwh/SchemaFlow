<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SchemaFlow è¿æ¥æµ‹è¯•</title>
  <style>
    * { box-sizing: border-box; }
    body { font-family: system-ui, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
    .container { max-width: 1200px; margin: 0 auto; }
    h1 { color: #333; }
    .panel { background: white; border-radius: 8px; padding: 16px; margin-bottom: 16px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .panel h2 { margin-top: 0; font-size: 16px; color: #666; }
    button { padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; margin-right: 8px; margin-bottom: 8px; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-primary { background: #3b82f6; color: white; }
    .btn-success { background: #22c55e; color: white; }
    .btn-danger { background: #ef4444; color: white; }
    .btn-secondary { background: #6b7280; color: white; }
    .status { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
    .status-connected { background: #dcfce7; color: #166534; }
    .status-disconnected { background: #fee2e2; color: #991b1b; }
    .status-running { background: #dbeafe; color: #1e40af; }
    #log { background: #1e1e1e; color: #d4d4d4; padding: 12px; border-radius: 4px; height: 300px; overflow-y: auto; font-family: monospace; font-size: 12px; }
    .log-info { color: #9cdcfe; }
    .log-success { color: #4ec9b0; }
    .log-error { color: #f14c4c; }
    .log-warn { color: #cca700; }
    #screenshot { max-width: 100%; max-height: 400px; border: 1px solid #ddd; border-radius: 4px; }
    .flex { display: flex; gap: 16px; }
    .flex-1 { flex: 1; }
    select, input { padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-right: 8px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ”§ SchemaFlow è¿æ¥æµ‹è¯•</h1>

    <!-- çŠ¶æ€é¢æ¿ -->
    <div class="panel">
      <h2>è¿æ¥çŠ¶æ€</h2>
      <p>
        API: <span id="apiStatus" class="status status-disconnected">æœªæ£€æµ‹</span>
        WebSocket: <span id="wsStatus" class="status status-disconnected">æœªè¿æ¥</span>
        æ‰§è¡Œ: <span id="execStatus" class="status status-disconnected">ç©ºé—²</span>
      </p>
      <button class="btn-primary" onclick="checkApi()">æ£€æµ‹ API</button>
      <button class="btn-secondary" onclick="loadWorkflows()">åŠ è½½å·¥ä½œæµ</button>
    </div>

    <!-- å·¥ä½œæµé€‰æ‹© -->
    <div class="panel">
      <h2>å·¥ä½œæµ</h2>
      <select id="workflowSelect" style="width: 300px;">
        <option value="">-- é€‰æ‹©å·¥ä½œæµ --</option>
      </select>
      <button class="btn-primary" onclick="createTestWorkflow()">åˆ›å»ºæµ‹è¯•å·¥ä½œæµ</button>
      <button class="btn-success" onclick="executeWorkflow()" id="btnExecute" disabled>æ‰§è¡Œ</button>
      <button class="btn-danger" onclick="stopExecution()" id="btnStop" disabled>åœæ­¢</button>
    </div>

    <div class="flex">
      <!-- æ—¥å¿—é¢æ¿ -->
      <div class="panel flex-1">
        <h2>æ‰§è¡Œæ—¥å¿—</h2>
        <div id="log"></div>
        <button class="btn-secondary" onclick="clearLog()" style="margin-top: 8px;">æ¸…ç©ºæ—¥å¿—</button>
      </div>

      <!-- æˆªå›¾é¢æ¿ -->
      <div class="panel" style="width: 400px;">
        <h2>å®æ—¶æˆªå›¾</h2>
        <div id="screenshotContainer" style="text-align: center; min-height: 200px; display: flex; align-items: center; justify-content: center; color: #999;">
          æ‰§è¡Œåæ˜¾ç¤ºæˆªå›¾
        </div>
      </div>
    </div>
  </div>

  <script>
    const API_BASE = '/api';
    let ws = null;
    let currentExecutionId = null;
    let currentWorkflowId = null;

    // æ—¥å¿—å‡½æ•°
    function log(message, type = 'info') {
      const logEl = document.getElementById('log');
      const time = new Date().toLocaleTimeString();
      const className = `log-${type}`;
      logEl.innerHTML += `<div class="${className}">[${time}] ${message}</div>`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function clearLog() {
      document.getElementById('log').innerHTML = '';
    }

    // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
    function updateStatus(id, connected, text) {
      const el = document.getElementById(id);
      el.textContent = text;
      el.className = `status ${connected ? 'status-connected' : 'status-disconnected'}`;
    }

    // æ£€æµ‹ API
    async function checkApi() {
      try {
        log('æ£€æµ‹ API è¿æ¥...');
        const resp = await fetch(`${API_BASE}/actions`);
        const actions = await resp.json();
        log(`API æ­£å¸¸ï¼Œå¯ç”¨èŠ‚ç‚¹: ${actions.length} ä¸ª`, 'success');
        updateStatus('apiStatus', true, 'å·²è¿æ¥');
        return true;
      } catch (e) {
        log(`API è¿æ¥å¤±è´¥: ${e.message}`, 'error');
        updateStatus('apiStatus', false, 'è¿æ¥å¤±è´¥');
        return false;
      }
    }

    // åŠ è½½å·¥ä½œæµåˆ—è¡¨
    async function loadWorkflows() {
      try {
        log('åŠ è½½å·¥ä½œæµåˆ—è¡¨...');
        const resp = await fetch(`${API_BASE}/workflows`);
        const workflows = await resp.json();

        const select = document.getElementById('workflowSelect');
        select.innerHTML = '<option value="">-- é€‰æ‹©å·¥ä½œæµ --</option>';
        workflows.forEach(wf => {
          select.innerHTML += `<option value="${wf.id}">${wf.name}</option>`;
        });

        log(`åŠ è½½äº† ${workflows.length} ä¸ªå·¥ä½œæµ`, 'success');
        document.getElementById('btnExecute').disabled = false;
      } catch (e) {
        log(`åŠ è½½å·¥ä½œæµå¤±è´¥: ${e.message}`, 'error');
      }
    }

    // åˆ›å»ºæµ‹è¯•å·¥ä½œæµ
    async function createTestWorkflow() {
      try {
        log('åˆ›å»ºæµ‹è¯•å·¥ä½œæµ...');
        const workflow = {
          name: 'æµ‹è¯•å·¥ä½œæµ-' + Date.now(),
          description: 'è‡ªåŠ¨åˆ›å»ºçš„æµ‹è¯•å·¥ä½œæµ',
          nodes: [
            { id: 'start_1', type: 'start', config: {} },
            { id: 'open_1', type: 'open_tab', config: { url: 'https://www.baidu.com' } },
            { id: 'wait_1', type: 'wait', config: { seconds: 2 } },
            { id: 'screenshot_1', type: 'screenshot', config: {} },
            { id: 'end_1', type: 'end', config: {} }
          ],
          edges: [
            { source: 'start_1', target: 'open_1' },
            { source: 'open_1', target: 'wait_1' },
            { source: 'wait_1', target: 'screenshot_1' },
            { source: 'screenshot_1', target: 'end_1' }
          ]
        };

        const resp = await fetch(`${API_BASE}/workflows`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(workflow)
        });
        const created = await resp.json();
        log(`åˆ›å»ºæˆåŠŸï¼ŒID: ${created.id}`, 'success');

        await loadWorkflows();
        document.getElementById('workflowSelect').value = created.id;
      } catch (e) {
        log(`åˆ›å»ºå·¥ä½œæµå¤±è´¥: ${e.message}`, 'error');
      }
    }

    // æ‰§è¡Œå·¥ä½œæµ
    async function executeWorkflow() {
      const workflowId = document.getElementById('workflowSelect').value;
      if (!workflowId) {
        log('è¯·å…ˆé€‰æ‹©å·¥ä½œæµ', 'warn');
        return;
      }

      try {
        // 1. è·å– execution_id
        log(`å¯åŠ¨å·¥ä½œæµæ‰§è¡Œ: ${workflowId}`);
        const resp = await fetch(`${API_BASE}/workflows/${workflowId}/execute`, { method: 'POST' });
        const { execution_id } = await resp.json();
        currentExecutionId = execution_id;
        currentWorkflowId = workflowId;
        log(`è·å–æ‰§è¡Œ ID: ${execution_id}`, 'success');

        // 2. è¿æ¥ WebSocket
        connectWebSocket(execution_id, workflowId);
      } catch (e) {
        log(`å¯åŠ¨æ‰§è¡Œå¤±è´¥: ${e.message}`, 'error');
      }
    }

    // è¿æ¥ WebSocket
    function connectWebSocket(executionId, workflowId) {
      if (ws) {
        ws.close();
      }

      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/api/ws/execution/${executionId}`;
      log(`è¿æ¥ WebSocket: ${wsUrl}`);

      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        log('WebSocket å·²è¿æ¥', 'success');
        updateStatus('wsStatus', true, 'å·²è¿æ¥');

        // å‘é€å¼€å§‹æ‰§è¡Œå‘½ä»¤
        log('å‘é€ start_execution å‘½ä»¤...');
        ws.send(JSON.stringify({
          type: 'start_execution',
          workflow_id: workflowId
        }));

        document.getElementById('btnExecute').disabled = true;
        document.getElementById('btnStop').disabled = false;
        updateStatus('execStatus', true, 'æ‰§è¡Œä¸­');
      };

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        handleMessage(data);
      };

      ws.onerror = (error) => {
        log(`WebSocket é”™è¯¯: ${error}`, 'error');
        updateStatus('wsStatus', false, 'é”™è¯¯');
      };

      ws.onclose = () => {
        log('WebSocket å·²æ–­å¼€');
        updateStatus('wsStatus', false, 'å·²æ–­å¼€');
        document.getElementById('btnExecute').disabled = false;
        document.getElementById('btnStop').disabled = true;
      };
    }

    // å¤„ç† WebSocket æ¶ˆæ¯
    function handleMessage(data) {
      switch (data.type) {
        case 'connected':
          log(`è¿æ¥ç¡®è®¤: ${data.execution_id}`, 'success');
          break;
        case 'execution_started':
          log(`æ‰§è¡Œå¼€å§‹ï¼ŒèŠ‚ç‚¹é¡ºåº: ${data.node_order?.join(' â†’ ')}`, 'success');
          break;
        case 'node_start':
          log(`â†’ èŠ‚ç‚¹å¼€å§‹: ${data.node_id} (${data.node_type})`);
          break;
        case 'node_complete':
          if (data.success) {
            log(`âœ“ èŠ‚ç‚¹å®Œæˆ: ${data.node_id}`, 'success');
          } else {
            log(`âœ— èŠ‚ç‚¹å¤±è´¥: ${data.node_id} - ${data.error}`, 'error');
          }
          break;
        case 'screenshot':
          log(`ğŸ“· æ”¶åˆ°æˆªå›¾ (${data.data?.length || 0} bytes)`);
          showScreenshot(data.data);
          break;
        case 'log':
          log(`[${data.level}] ${data.message}`, data.level === 'error' ? 'error' : 'info');
          break;
        case 'execution_complete':
          log(`æ‰§è¡Œå®Œæˆï¼æˆåŠŸ: ${data.success}, è€—æ—¶: ${data.duration?.toFixed(2)}s`, data.success ? 'success' : 'error');
          updateStatus('execStatus', false, 'å·²å®Œæˆ');
          document.getElementById('btnExecute').disabled = false;
          document.getElementById('btnStop').disabled = true;
          break;
        case 'error':
          log(`é”™è¯¯: ${data.message}`, 'error');
          updateStatus('execStatus', false, 'é”™è¯¯');
          break;
        default:
          log(`æœªçŸ¥æ¶ˆæ¯: ${data.type}`);
      }
    }

    // æ˜¾ç¤ºæˆªå›¾
    function showScreenshot(base64Data) {
      const container = document.getElementById('screenshotContainer');
      if (base64Data) {
        container.innerHTML = `<img id="screenshot" src="data:image/png;base64,${base64Data}" alt="æˆªå›¾">`;
      }
    }

    // åœæ­¢æ‰§è¡Œ
    function stopExecution() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        log('å‘é€åœæ­¢å‘½ä»¤...');
        ws.send(JSON.stringify({ type: 'stop_execution' }));
      }
    }

    // é¡µé¢åŠ è½½æ—¶æ£€æµ‹
    window.onload = async () => {
      log('é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹æ£€æµ‹...');
      await checkApi();
      await loadWorkflows();
    };
  </script>
</body>
</html>
