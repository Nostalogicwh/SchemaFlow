# v0.5.2 优化实现计划

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** 完成实时截图放大、API 帮助增强、后端 API 测试三个优化项

**Architecture:** 新建 ImageViewer 组件复用于截图查看；修改 Header.tsx 增加 Skill 标签页；新建 API 测试文件

**Tech Stack:** React + TypeScript + Tailwind CSS（前端）、pytest + httpx（后端）

---

## Task 1: 创建 ImageViewer 组件

**Files:**
- Create: `frontend/src/components/ui/ImageViewer.tsx`

**Step 1: 创建 ImageViewer 组件**

```typescript
import { memo, useCallback, useEffect, useRef, useState } from 'react'
import { X, Download, ZoomIn, ZoomOut, RotateCcw } from 'lucide-react'

interface ImageViewerProps {
  src: string
  isOpen: boolean
  onClose: () => void
  downloadable?: boolean
  filename?: string
}

function ImageViewer({ src, isOpen, onClose, downloadable = false, filename = 'image.jpg' }: ImageViewerProps) {
  const [scale, setScale] = useState(1)
  const [translate, setTranslate] = useState({ x: 0, y: 0 })
  const [isDragging, setIsDragging] = useState(false)
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 })
  const containerRef = useRef<HTMLDivElement>(null)

  const resetTransform = useCallback(() => {
    setScale(1)
    setTranslate({ x: 0, y: 0 })
  }, [])

  useEffect(() => {
    if (isOpen) {
      resetTransform()
    }
  }, [isOpen, resetTransform])

  useEffect(() => {
    if (!isOpen) return

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose()
    }
    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [isOpen, onClose])

  const handleWheel = useCallback((e: React.WheelEvent) => {
    e.preventDefault()
    const delta = e.deltaY > 0 ? -0.1 : 0.1
    setScale(prev => Math.min(Math.max(0.5, prev + delta), 5))
  }, [])

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    if (e.button !== 0) return
    setIsDragging(true)
    setDragStart({ x: e.clientX - translate.x, y: e.clientY - translate.y })
  }, [translate])

  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    if (!isDragging) return
    setTranslate({
      x: e.clientX - dragStart.x,
      y: e.clientY - dragStart.y
    })
  }, [isDragging, dragStart])

  const handleMouseUp = useCallback(() => {
    setIsDragging(false)
  }, [])

  const handleDoubleClick = useCallback(() => {
    resetTransform()
  }, [resetTransform])

  const handleDownload = useCallback(() => {
    const link = document.createElement('a')
    link.href = src.startsWith('data:') ? src : src
    link.download = filename
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
  }, [src, filename])

  const handleBackdropClick = useCallback((e: React.MouseEvent) => {
    if (e.target === e.currentTarget) onClose()
  }, [onClose])

  const handleZoomIn = () => setScale(prev => Math.min(prev + 0.25, 5))
  const handleZoomOut = () => setScale(prev => Math.max(prev - 0.25, 0.5))

  if (!isOpen) return null

  return (
    <div
      className="fixed inset-0 bg-black/90 z-50 flex items-center justify-center"
      onClick={handleBackdropClick}
    >
      <div className="absolute top-4 right-4 flex items-center gap-2 z-10">
        <button
          onClick={handleZoomOut}
          className="p-2 bg-white/10 hover:bg-white/20 rounded-lg text-white transition-colors"
          title="缩小"
        >
          <ZoomOut className="w-5 h-5" />
        </button>
        <span className="text-white text-sm min-w-[60px] text-center">{Math.round(scale * 100)}%</span>
        <button
          onClick={handleZoomIn}
          className="p-2 bg-white/10 hover:bg-white/20 rounded-lg text-white transition-colors"
          title="放大"
        >
          <ZoomIn className="w-5 h-5" />
        </button>
        <button
          onClick={resetTransform}
          className="p-2 bg-white/10 hover:bg-white/20 rounded-lg text-white transition-colors"
          title="重置"
        >
          <RotateCcw className="w-5 h-5" />
        </button>
        {downloadable && (
          <button
            onClick={handleDownload}
            className="p-2 bg-white/10 hover:bg-white/20 rounded-lg text-white transition-colors"
            title="下载"
          >
            <Download className="w-5 h-5" />
          </button>
        )}
        <button
          onClick={onClose}
          className="p-2 bg-white/10 hover:bg-white/20 rounded-lg text-white transition-colors"
          title="关闭"
        >
          <X className="w-5 h-5" />
        </button>
      </div>

      <div
        ref={containerRef}
        className="w-full h-full flex items-center justify-center overflow-hidden cursor-grab active:cursor-grabbing"
        onWheel={handleWheel}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
      >
        <img
          src={src}
          alt="预览"
          className="max-w-none select-none"
          style={{
            transform: `translate(${translate.x}px, ${translate.y}px) scale(${scale})`,
            transition: isDragging ? 'none' : 'transform 0.1s ease-out'
          }}
          onDoubleClick={handleDoubleClick}
          draggable={false}
        />
      </div>
    </div>
  )
}

export default memo(ImageViewer)
```

**Step 2: 验证组件可导入**

Run: `cd frontend && npm run build`
Expected: 无错误

**Step 3: Commit**

```bash
git add frontend/src/components/ui/ImageViewer.tsx
git commit -m "feat: add ImageViewer component for image zoom and pan"
```

---

## Task 2: ExecutionPanel 添加图片放大功能

**Files:**
- Modify: `frontend/src/components/ExecutionPanel/index.tsx`

**Step 1: 导入 ImageViewer 并添加状态**

在文件顶部导入区域添加：
```typescript
import ImageViewer from '../ui/ImageViewer'
```

在 `CompactModeLayout` 组件内添加状态（约第 110 行附近）：
```typescript
const [viewerOpen, setViewerOpen] = useState(false)
```

**Step 2: 修改截图显示区域，添加点击事件**

找到实时截图的 `<img>` 标签（约第 145 行），修改为：
```typescript
<img
  src={`data:image/jpeg;base64,${screenshot}`}
  alt="实时截图"
  className="w-full h-full object-contain cursor-pointer hover:opacity-90 transition-opacity"
  onClick={() => setViewerOpen(true)}
/>
```

**Step 3: 在 CompactModeLayout 返回的 JSX 末尾添加 ImageViewer**

在 `return (` 的最后 `</div>` 之前添加：
```typescript
<ImageViewer
  src={`data:image/jpeg;base64,${screenshot}`}
  isOpen={viewerOpen}
  onClose={() => setViewerOpen(false)}
/>
```

**Step 4: 验证修改**

Run: `cd frontend && npm run build`
Expected: 无错误

**Step 5: Commit**

```bash
git add frontend/src/components/ExecutionPanel/index.tsx
git commit -m "feat: add click-to-zoom for real-time screenshot"
```

---

## Task 3: NodePanel 添加截图节点放大功能

**Files:**
- Modify: `frontend/src/components/FlowEditor/panels/NodePanel.tsx`

**Step 1: 导入 ImageViewer 并添加状态**

在文件顶部导入区域添加：
```typescript
import ImageViewer from '../../ui/ImageViewer'
```

在组件内添加状态（约第 90 行后）：
```typescript
const [viewerOpen, setViewerOpen] = useState(false)
```

**Step 2: 修改截图预览区域，添加点击事件**

找到截图预览的 `<img>` 标签（约第 200 行附近），修改为：
```typescript
{screenshotPath && (
  <div className="mt-2">
    <label className="block text-sm font-medium text-gray-700 mb-1">截图预览</label>
    <img
      src={`http://localhost:8000${screenshotPath}`}
      alt="截图预览"
      className="w-full rounded border border-gray-200 cursor-pointer hover:opacity-90 transition-opacity"
      onClick={() => setViewerOpen(true)}
    />
  </div>
)}
```

**Step 3: 在组件返回的 JSX 末尾添加 ImageViewer**

在 `return (` 的最后 `</div>` 之前添加：
```typescript
{screenshotPath && (
  <ImageViewer
    src={`http://localhost:8000${screenshotPath}`}
    isOpen={viewerOpen}
    onClose={() => setViewerOpen(false)}
    downloadable
    filename={`screenshot-${selectedNode?.id}.jpg`}
  />
)}
```

**Step 4: 验证修改**

Run: `cd frontend && npm run build`
Expected: 无错误

**Step 5: Commit**

```bash
git add frontend/src/components/FlowEditor/panels/NodePanel.tsx
git commit -m "feat: add click-to-zoom and download for screenshot node preview"
```

---

## Task 4: API 帮助弹窗增加 Skill 标签页

**Files:**
- Modify: `frontend/src/components/Header.tsx`

**Step 1: 添加 Skill 标签页状态和内容**

在 `ApiTriggerHelpButton` 组件内，找到标签页状态定义处，添加 `skill` 类型：
```typescript
type TabType = 'endpoint' | 'curl' | 'javascript' | 'skill'
```

**Step 2: 添加 Skill 内容常量**

在组件内添加：
```typescript
const SKILL_MD_CONTENT = `---
name: schemaflow-trigger
description: |
  Trigger SchemaFlow workflows via API. Use when user wants to:
  (1) Execute a saved workflow programmatically
  (2) Get execution results from a triggered workflow
  (3) Integrate SchemaFlow with other automation tools
---

# SchemaFlow Workflow Trigger

## Configuration

Set these environment variables or modify the script:
- \`SCHEMAFLOW_API_KEY\`: Your API key
- \`SCHEMAFLOW_BASE_URL\`: Default is http://localhost:8000

## Usage

\`scripts/trigger.py\` provides helper functions:

- \`trigger_workflow(workflow_id, variables, headless)\` - Start execution
- \`get_result(execution_id)\` - Get execution result

## Example

\`\`\`python
import asyncio
from trigger import trigger_workflow, get_result

async def main():
    # Trigger workflow
    result = await trigger_workflow("workflow-id", {"url": "https://example.com"})
    print(f"Execution started: {result['execution_id']}")
    
    # Get result
    status = await get_result(result['execution_id'])
    print(f"Status: {status['status']}")

asyncio.run(main())
\`\`\`
`

const TRIGGER_PY_CONTENT = `import os
import httpx

API_KEY = os.getenv("SCHEMAFLOW_API_KEY", "YOUR_API_KEY")
BASE_URL = os.getenv("SCHEMAFLOW_BASE_URL", "http://localhost:8000")

async def trigger_workflow(workflow_id: str, variables: dict = None, headless: bool = True) -> dict:
    """触发工作流执行"""
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{BASE_URL}/api/trigger/{workflow_id}",
            headers={"X-API-Key": API_KEY},
            json={"variables": variables or {}, "headless": headless},
            timeout=30.0
        )
        response.raise_for_status()
        return response.json()

async def get_result(execution_id: str) -> dict:
    """获取执行结果"""
    async with httpx.AsyncClient() as client:
        response = await client.get(
            f"{BASE_URL}/api/trigger/{execution_id}/result",
            headers={"X-API-Key": API_KEY},
            timeout=30.0
        )
        response.raise_for_status()
        return response.json()

async def wait_for_completion(execution_id: str, timeout: float = 300.0, poll_interval: float = 2.0) -> dict:
    """等待执行完成并返回结果"""
    import asyncio
    start_time = asyncio.get_event_loop().time()
    
    while True:
        result = await get_result(execution_id)
        if result.get("status") in ("completed", "failed", "cancelled"):
            return result
        
        elapsed = asyncio.get_event_loop().time() - start_time
        if elapsed >= timeout:
            raise TimeoutError(f"Execution {execution_id} did not complete within {timeout}s")
        
        await asyncio.sleep(poll_interval)
`
```

**Step 3: 添加 Skill 标签页 UI**

在标签页按钮区域添加：
```typescript
<button
  onClick={() => setActiveTab('skill')}
  className={`px-3 py-1.5 text-sm rounded-md transition-colors ${
    activeTab === 'skill'
      ? 'bg-blue-500 text-white'
      : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
  }`}
>
  Skill
</button>
```

在标签页内容区域添加：
```typescript
{activeTab === 'skill' && (
  <div className="space-y-4">
    <div>
      <h4 className="font-medium text-gray-900 mb-2">Skill 文件结构</h4>
      <pre className="bg-gray-50 p-3 rounded text-sm overflow-x-auto text-gray-800">
{`schemaflow-trigger/
├── SKILL.md
└── scripts/
    └── trigger.py`}
      </pre>
    </div>
    
    <div>
      <div className="flex items-center justify-between mb-2">
        <h4 className="font-medium text-gray-900">SKILL.md</h4>
        <button
          onClick={() => copyToClipboard(SKILL_MD_CONTENT)}
          className="text-sm text-blue-500 hover:text-blue-600"
        >
          复制
        </button>
      </div>
      <pre className="bg-gray-50 p-3 rounded text-sm overflow-x-auto text-gray-800 whitespace-pre-wrap">
        {SKILL_MD_CONTENT}
      </pre>
    </div>
    
    <div>
      <div className="flex items-center justify-between mb-2">
        <h4 className="font-medium text-gray-900">scripts/trigger.py</h4>
        <button
          onClick={() => copyToClipboard(TRIGGER_PY_CONTENT)}
          className="text-sm text-blue-500 hover:text-blue-600"
        >
          复制
        </button>
      </div>
      <pre className="bg-gray-50 p-3 rounded text-sm overflow-x-auto text-gray-800">
        {TRIGGER_PY_CONTENT}
      </pre>
    </div>
    
    <div className="flex gap-2 pt-2">
      <button
        onClick={() => downloadSkill()}
        className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm"
      >
        下载 Skill 包
      </button>
    </div>
  </div>
)}
```

**Step 4: 添加复制和下载函数**

在组件内添加：
```typescript
const copyToClipboard = (text: string) => {
  navigator.clipboard.writeText(text)
  // 可选：添加 toast 提示
}

const downloadSkill = () => {
  const skillContent = `schemaflow-trigger/SKILL.md\n${'='.repeat(40)}\n${SKILL_MD_CONTENT}\n\nschemaflow-trigger/scripts/trigger.py\n${'='.repeat(40)}\n${TRIGGER_PY_CONTENT}`
  const blob = new Blob([skillContent], { type: 'text/plain' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = 'schemaflow-trigger.txt'
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}
```

**Step 5: 验证修改**

Run: `cd frontend && npm run build`
Expected: 无错误

**Step 6: Commit**

```bash
git add frontend/src/components/Header.tsx
git commit -m "feat: add Skill tab to API help dialog with copy and download"
```

---

## Task 5: 创建后端 API 测试文件

**Files:**
- Create: `backend/tests/test_trigger_api.py`

**Step 1: 创建测试文件**

```python
import pytest
from httpx import AsyncClient


class TestTriggerAPI:
    """API 触发端点测试"""

    async def test_trigger_workflow_missing_api_key(self, async_client: AsyncClient, test_workflow):
        """缺少 API Key 应返回 401"""
        response = await async_client.post(
            f"/api/trigger/{test_workflow.id}",
            json={"variables": {}, "headless": True}
        )
        assert response.status_code == 401

    async def test_trigger_workflow_invalid_api_key(self, async_client: AsyncClient, test_workflow):
        """无效 API Key 应返回 401"""
        response = await async_client.post(
            f"/api/trigger/{test_workflow.id}",
            headers={"X-API-Key": "invalid_key"},
            json={"variables": {}, "headless": True}
        )
        assert response.status_code == 401

    async def test_trigger_workflow_not_found(self, async_client: AsyncClient, api_key: str):
        """工作流不存在应返回 404"""
        response = await async_client.post(
            "/api/trigger/non-existent-id",
            headers={"X-API-Key": api_key},
            json={"variables": {}, "headless": True}
        )
        assert response.status_code == 404

    async def test_get_result_not_found(self, async_client: AsyncClient, api_key: str):
        """执行 ID 不存在应返回 404"""
        response = await async_client.get(
            "/api/trigger/non-existent-execution/result",
            headers={"X-API-Key": api_key}
        )
        assert response.status_code == 404

    async def test_api_key_status_valid(self, async_client: AsyncClient, api_key: str):
        """有效 API Key 状态检查"""
        response = await async_client.get(
            "/api/trigger/api-key/status",
            headers={"X-API-Key": api_key}
        )
        assert response.status_code == 200
        data = response.json()
        assert data["valid"] is True

    async def test_api_key_status_invalid(self, async_client: AsyncClient):
        """无效 API Key 状态检查"""
        response = await async_client.get(
            "/api/trigger/api-key/status",
            headers={"X-API-Key": "invalid_key"}
        )
        assert response.status_code == 200
        data = response.json()
        assert data["valid"] is False
```

**Step 2: 添加测试 fixtures 到 conftest.py**

在 `backend/tests/conftest.py` 中添加：
```python
import pytest
from api.auth import get_valid_api_key


@pytest.fixture
def api_key():
    """获取有效的 API Key"""
    return get_valid_api_key()
```

**Step 3: 运行测试**

Run: `cd backend && .venv/bin/python -m pytest tests/test_trigger_api.py -v`
Expected: 所有测试通过

**Step 4: Commit**

```bash
git add backend/tests/test_trigger_api.py backend/tests/conftest.py
git commit -m "test: add API trigger endpoint tests"
```

---

## Task 6: 最终验证

**Step 1: 前端构建检查**

Run: `cd frontend && npm run build`
Expected: 构建成功

**Step 2: 后端测试检查**

Run: `cd backend && .venv/bin/python -m pytest tests/ -v`
Expected: 所有测试通过

**Step 3: 更新 TODO 文档**

将 `docs/v0.5/v0.5.2/TODO.md` 中 OPT-08 和 NEW-01 的待优化项标记为完成。

**Step 4: 最终 Commit**

```bash
git add docs/v0.5/v0.5.2/TODO.md docs/plans/
git commit -m "docs: mark v0.5.2 optimization tasks as completed"
```

---

## 执行摘要

| Task | 描述 | 文件 |
|------|------|------|
| 1 | 创建 ImageViewer 组件 | `frontend/src/components/ui/ImageViewer.tsx` |
| 2 | ExecutionPanel 放大功能 | `frontend/src/components/ExecutionPanel/index.tsx` |
| 3 | NodePanel 放大功能 | `frontend/src/components/FlowEditor/panels/NodePanel.tsx` |
| 4 | API 帮助 Skill 标签页 | `frontend/src/components/Header.tsx` |
| 5 | API 测试用例 | `backend/tests/test_trigger_api.py` |
| 6 | 最终验证 | - |
